<html>
    <head>
    <meta http-equiv=Content-Type  content="text/html; charset=utf8">
    </head>

    <body>
    <h1>前言</h1>
<p>刷LeetCode是一段艰辛的旅程，特别对于像我这样算法不是很扎实，平时脱离编程的人。
但为了找到一份像样的工作，还是硬着头皮刷了。编程、计算机从来也没有成为我的爱，
虽然和它打交道了十年，最终它还是只沦为了混饭吃的工具。</p>
<p>正是由于自己在算法方面悟性和经验的欠缺，在刷题时，参考了很多别人的代码。为了
不让自己那么快就忘掉，决定把每道题的思路都记录下来。好记心不如烂笔头，脑袋里
想不清楚，那就在就在纸上写写画画，未必能让你通透地理解，至少对你的记忆也是有
帮助的。</p>
<p>之前，也有一些人将LeetCode的题解(<a href="https://www.gitbook.com/book/siddontang/leetcode-solution/details">siddontang</a>,<a href="https://github.com/soulmachine/leetcode">soulmachine</a>,<a href="http://algorithm.yuanbin.me/">yuanbin</a>)
整理发布了，但他们大多将题目按照数据
结构来分类，而不是按照思路和解法来分类。这种分类方式对于更好地回顾，让
知识更成体系有帮助，但对于引导思路来讲，还是显得零碎了一些。我希望尽量将题目按
照解题的思路来分类，从而找到其中的门路，遇到了新的题，至少就不会那么茫然无措了。</p>
<p>算法的基本思路主要有枚举、递归、贪心、动态规划。其中:
<em> 动态规划能解的题通常有递归解法。
</em> 贪心算法可以看做将问题分解为1和n-1子问题的递归解法。
<em> 递归算法又可以分为：
    * 分治法：将n问题分解为两个n/2子问题 
    * 其它分法：如将n问题分解为1和n-1子问题，或者分解为n-1和1子问题，或者分为3段
      等等。
</em> 枚举重要的是不能将一个可能的解重复验证。枚举的方式因题目的不同而不同，不过对于
    常用的数据结构，还是有一些经典的枚举算法。如果能把题目转化为这些数据结构上的
    问题，就能够更容易地找到枚举方法。
    * 图：
        * 深度优先搜索算法
        * 广度优先搜索算法
    * 树：
        * 先序遍历
        * 中序遍历
        * 后序遍历</p>
<p>除了上述的几种通用思路外，还有一些想法，对你解题也会有一些帮助：
<em> 看有没有长得像的经典题目和算法。当然，这就要求你的脑袋里有一些存货。
</em> 剪枝。只要你多花点时间，一个问题的枚举解法，你总能找到。如果效率不是很高的话，
    那就试着想想哪些值是不可能成为解的。然后在枚举的过程中，直接将那些不可能的
    值剔除。</p>
    </body>
</html>